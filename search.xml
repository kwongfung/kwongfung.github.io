<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Google Objective-C Style Guide]]></title>
      <url>%2F2017%2F04%2F08%2F2017-04-08-Google-Objective-C-Style-Guide%2F</url>
      <content type="text"><![CDATA[This is Google Objective-C Style Guide. BackgroundObjective-C is a very dynamic, object-oriented extension of C. It’s designed to be easy to use and read, while enabling sophisticated object-oriented design. It is the primary development language for new applications on Mac OS X and the iPhone.Cocoa is one of the main application frameworks on Mac OS X. It is a collection of Objective-C classes that provide for rapid development of full-featured Mac OS X applications.Apple has already written a very good, and widely accepted, coding guide for Objective-C. Google has also written a similar guide for C++. This Objective-C guide aims to be a very natural combination of Apple’s and Google’s general recommendations. So, before reading this guide, please make sure you’ve read: Apple’s Cocoa Coding Guidelines Google’s Open Source C ++ Style Guide The purpose of this document is to describe the Objective-C (and Objective-C++) coding guidelines and practices that should be used for all Mac OS X code. Many of these guidelines have evolved and been proven over time on other projects and teams. Open-source projects developed by Google conform to the requirements in this guide.Note that this guide is not an Objective-C tutorial. We assume that the reader is familiar with the language. If you are new to Objective-C or need a refresher, please read Programming with Objective-C . ExampleThey say an example is worth a thousand words so let’s start off with an example that should give you a feel for the style, spacing, naming, etc.An example header file, demonstrating the correct commenting and spacing for an @interface declaration #import &quot;Foo.h&quot; @implementation Foo { NSString *_bar; NSString *_foo; } + (instancetype)fooWithBar:(NSString *)bar { return [[[self alloc] initWithBar:bar] autorelease]; } // Must always override super&apos;s designated initializer. - (instancetype)init { return [self initWithBar:nil]; } - (instancetype)initWithBar:(NSString *)bar { if ((self = [super init])) { _bar = [bar copy]; _bam = [[NSString alloc] initWithFormat:@&quot;hi %d&quot;, 3]; } return self; } - (void)dealloc { [_bar release]; [_bam release]; [super dealloc]; } - (NSString *)bar { return _bar; } - (void)setBar:(NSString *)bar { [_bar autorelease]; _bar = [bar copy]; } - (BOOL)doWorkWithBlah:(NSString *)blah { // ... return NO; } @end An example source file, demonstrating the correct commenting and spacing for the @implementation of an interface. It also includes the reference implementations for important methods like getters and setters,init, and dealloc. #import &quot;Foo.h&quot; @implementation Foo { NSString *_bar; NSString *_foo; } + (instancetype)fooWithBar:(NSString *)bar { return [[[self alloc] initWithBar:bar] autorelease]; } // Must always override super&apos;s designated initializer. - (instancetype)init { return [self initWithBar:nil]; } - (instancetype)initWithBar:(NSString *)bar { if ((self = [super init])) { _bar = [bar copy]; _bam = [[NSString alloc] initWithFormat:@&quot;hi %d&quot;, 3]; } return self; } - (void)dealloc { [_bar release]; [_bam release]; [super dealloc]; } - (NSString *)bar { return _bar; } - (void)setBar:(NSString *)bar { [_bar autorelease]; _bar = [bar copy]; } - (BOOL)doWorkWithBlah:(NSString *)blah { // ... return NO; } @end Blank lines before and after @interface, @implementation, and @end are optional. If your @interface declares instance variables, a blank line should come after the closing brace (}). Unless an interface or implementation is very short, such as when declaring a handful of private methods or a bridge class, adding blank lines usually helps readability. Spacing And FormattingSpaces vs. TabsUse only spaces, and indent 2 spaces at a time.We use spaces for indentation. Do not use tabs in your code. You should set your editor to emit spaces when you hit the tab key. Line LengthThe maximum line length for Objective-C and Objective-C++ files is 100 columns. Projects may opt to use an 80 column limit for consistency with the C++ style guide.You can make violations easier to spot by enabling Preferences > Text Editing > Page guide at column: 100 in Xcode. Method Declarations and DefinitionsOne space should be used between the - or + and the return type, and no spacing in the parameter list except between parameters.Methods should look like this: - (void)doSomethingWithString:(NSString *)theString { ... } The spacing before the asterisk is optional. When adding new code, be consistent with the surrounding file’s style.If you have too many parameters to fit on one line, giving each its own line is preferred. If multiple lines are used, align each using the colon before the parameter. - (void)doSomethingWith:(GTMFoo *)theFoo rect:(NSRect)theRect interval:(float)theInterval { ... } When the first keyword is shorter than the others, indent the later lines by at least four spaces, maintaining colon alignment: - (void)short:(GTMFoo *)theFoo longKeyword:(NSRect)theRect evenLongerKeyword:(float)theInterval error:(NSError **)theError { ... } Method InvocationsMethod invocations should be formatted much like method declarations. When there’s a choice of formatting styles, follow the convention already used in a given source file.Invocations should have all arguments on one line: [myObject doFooWith:arg1 name:arg2 error:arg3];or have one argument per line, with colons aligned: [myObject doFooWith:arg1 name:arg2 error:arg3];Don’t use any of these styles: [myObject doFooWith:arg1 name:arg2 // some lines with &gt;1 arg error:arg3]; [myObject doFooWith:arg1 name:arg2 error:arg3]; [myObject doFooWith:arg1 name:arg2 // aligning keywords instead of colons error:arg3]; As with declarations and definitions, when the first keyword is shorter than the others, indent the later lines by at least four spaces, maintaining colon alignment: [myObj short:arg1 longKeyword:arg2 evenLongerKeyword:arg3 error:arg4];Invocations containing inlined blocks may have their segments left-aligned at a four space indent. @public and @privateThe @public and@private access modifiers should be indented by 1 space.This is similar to public, private, and protected in C++. @interface MyClass : NSObject { @public ... @private ... } @end ExceptionsFormat exceptions with each @ label on its own line and a space between the @ label and the opening brace ({), as well as between the @catch and the caught object declaration.If you must use Obj-C exceptions, format them as follows. However, see Avoid Throwing Exceptions for reasons why you should not be using exceptions. @try { foo(); } @catch (NSException *ex) { bar(ex); } @finally { baz(); } ProtocolsThere should not be a space between the type identifier and the name of the protocol encased in angle brackets.This applies to class declarations, instance variables, and method declarations. For example: @interface MyProtocoledClass : NSObject { @private id _delegate; } - (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate; @end BlocksCode inside blocks should be indented four spaces.There are several appropriate style rules, depending on how long the block is:• If the block can fit on one line, no wrapping is necessary.• If it has to wrap, the closing brace should line up with the first character of the line on which the block is declared.• Code within the block should be indented four spaces.• If the block is large, e.g. more than 20 lines, it is recommended to move it out-of-line into a local variable.• If the block takes no parameters, there are no spaces between the characters ^{. If the block takes parameters, there is no space between the ^( characters, but there is one space between the ) { characters.• Invocations containing inlined blocks may have their segments left-aligned at a four-space indent. This helps when invocations contain multiple inlined blocks.• Two space indents inside blocks are also allowed, but should only be used when it’s consistent with the rest of the project’s code. // The entire block fits on one line. [operation setCompletionBlock:^{ [self onOperationDone]; }]; // The block can be put on a new line, indented four spaces, with the // closing brace aligned with the first character of the line on which // block was declared. [operation setCompletionBlock:^{ [self.delegate newDataAvailable]; }]; // Using a block with a C API follows the same alignment and spacing // rules as with Objective-C. dispatch_async(_fileIOQueue, ^{ NSString* path = [self sessionFilePath]; if (path) { // ... } }); // An example where the parameter wraps and the block declaration fits // on the same line. Note the spacing of |^(SessionWindow *window) {| // compared to |^{| above. [[SessionService sharedService] loadWindowWithCompletionBlock:^(SessionWindow *window) { if (window) { [self windowDidLoad:window]; } else { [self errorLoadingWindow]; } }]; // An example where the parameter wraps and the block declaration does // not fit on the same line as the name. [[SessionService sharedService] loadWindowWithCompletionBlock: ^(SessionWindow *window) { if (window) { [self windowDidLoad:window]; } else { [self errorLoadingWindow]; } }]; // Large blocks can be declared out-of-line. void (^largeBlock)(void) = ^{ // ... }; [_operationQueue addOperationWithBlock:largeBlock]; // An example with multiple inlined blocks in one invocation. [myObject doSomethingWith:arg1 firstBlock:^(Foo *a) { // ... } secondBlock:^(Bar *b) { // ... }]; Container LiteralsFor projects using Xcode 4.4 or later and clang, the use of container (array and dictionary) literals is encouraged. If split across multiple lines, the contents should be indented two spaces.If the collection fits on one line, put a single space after the opening and before the closing brackets. NSArray* array = @[ [foo description], @”Another String”, [bar description] ]; NSDictionary* dict = @{ NSForegroundColorAttributeName : [NSColor redColor] }; Not: NSArray* array = @[[foo description], [bar description]]; NSDictionary* dict = @{NSForegroundColorAttributeName: [NSColor redColor]}; If the collection spans more than a single line, place the opening bracket on the same line as the declaration, indent the body by two spaces, and place the closing bracket on a new line that is indented to the same level as the opening bracket. NSArray* array = @[ @”This”, @”is”, @”an”, @”array” ]; NSDictionary* dictionary = @{ NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12], NSForegroundColorAttributeName : fontColor }; For dictionary literals, there should be one space before the colon and at least one space after it (to optionally align the values). NSDictionary* option1 = @{ NSFontAttributeName : [NSFont fontWithName:@”Helvetica-Bold” size:12], NSForegroundColorAttributeName : fontColor }; NSDictionary* option2 = @{ NSFontAttributeName : [NSFont fontWithName:@&quot;Arial&quot; size:12], NSForegroundColorAttributeName : fontColor }; The following are all incorrect: // There should be a space before the colon. NSDictionary* wrong = @{ AKey: @”b”, BLongerKey: @”c”, }; // The items should each be on a new line, or the entire expression // should fit on one line. NSDictionary* alsoWrong= @{ AKey : @&quot;a&quot;, BLongerKey : @&quot;b&quot; }; // There should be no variable space before the colon, only after. NSDictionary* stillWrong = @{ AKey : @&quot;b&quot;, BLongerKey : @&quot;c&quot;, }; NamingNaming rules are very important in maintainable code. Objective-C method names tend to be very long, but this has the benefit that a block of code can almost read like prose, thus rendering many comments unnecessary.When writing pure Objective-C code, we mostly follow standard Objective-C naming rules. These naming guidelines may differ significantly from those outlined in the C++ style guide. For example, Google’s C++ style guide recommends the use of underscores between words in variable names, whereas this guide recommends the use of intercaps, which is standard in the Objective-C community.Any class, category, method, or variable name may use all capitals for initialisms within the name. This follows Apple’s standard of using all capitals within a name for initialisms such as URL, TIFF, and EXIF.When writing Objective-C++, however, things are not so cut and dry. Many projects need to implement cross-platform C++ APIs with some Objective-C or Cocoa, or bridge between a C++ back-end and a native Cocoa front-end. This leads to situations where the two guides are directly at odds.Our solution is that the style follows that of the method/function being implemented. If you’re in an @implementation block, use the Objective-C naming rules. If you’re implementing a method for a C++ class, use the C++ naming rules. This avoids the situation where instance variable and local variable naming rules are mixed within a single function, which would be a serious detriment to readability. File NamesFile names should reflect the name of the class implementation that they contain—including case. Follow the convention that your project uses.File extensions should be as follows: | .h | C/C++/Objective-C header file || .m | Objective-C implementation file || .mm | Objective-C++ implementation file || .cc | Pure C++ implementation file || .c | C implementation file | File names for categories should include the name of the class being extended, e.g. GTMNSString+Utils.h or GTMNSTextView+Autocomplete.h Objective-C++Within a source file, Objective-C++ follows the style of the function/method you’re implementing.In order to minimize clashes between the differing naming styles when mixing Cocoa/Objective-C and C++, follow the style of the method being implemented. If you’re in an @implementation block, use the Objective-C naming rules. If you’re implementing a method for a C++ class, use the C++ naming rules. // file: cross_platform_header.h class CrossPlatformAPI { public: ... int DoSomethingPlatformSpecific(); // impl on each platform private: int an_instance_var_; }; // file: mac_implementation.mm #include &quot;cross_platform_header.h&quot; // A typical Objective-C class, using Objective-C naming. @interface MyDelegate : NSObject { @private int _instanceVar; CrossPlatformAPI* _backEndObject; } - (void)respondToSomething:(id)something; @end @implementation MyDelegate - (void)respondToSomething:(id)something { // bridge from Cocoa through our C++ backend _instanceVar = _backEndObject-&gt;DoSomethingPlatformSpecific(); NSString* tempString = [NSString stringWithFormat:@&quot;%d&quot;, _instanceVar]; NSLog(@&quot;%@&quot;, tempString); } @end // The platform-specific implementation of the C++ class, using // C++ naming. int CrossPlatformAPI::DoSomethingPlatformSpecific() { NSString* temp_string = [NSString stringWithFormat:@&quot;%d&quot;, an_instance_var_]; NSLog(@&quot;%@&quot;, temp_string); return [temp_string intValue]; } Class NamesClass names (along with category and protocol names) should start as uppercase and use mixed case to delimit words.When designing code to be shared across multiple applications, prefixes are acceptable and recommended (e.g. GTMSendMessage). Prefixes are also recommended for classes of large applications that depend on external libraries. Category NamesCategory names should start with a 2 or 3 character prefix identifying the category as part of a project or open for general use. The category name should incorporate the name of the class it’s extending.For example, if we want to create a category on NSString for parsing, we would put the category in a file named GTMNSString+Parsing.h, and the category itself would be named GTMStringParsingAdditions (yes, we know the file name and the category name do not match, but this file could have many separate categories related to parsing). Methods in that category should share the prefix (gtm_myCategoryMethodOnAString:) in order to prevent collisions in Objective-C which only has a single namespace. If the code isn’t meant to be shared and/or doesn’t run in a different address-space, the method naming isn’t quite as important.There should be a single space between the class name and the opening parenthesis of the category. // Extending a framework class: @interface NSString (GTMStringParsingAdditions) - (NSString *)gtm_foobarString; @end // Making your methods and properties private: @interface FoobarViewController () @property(nonatomic, retain) NSView *dongleView; - (void)performLayout; @end Objective-C Method NamesMethod names should start as lowercase and then use mixed case. Each named parameter should also start as lowercase.The method name should read like a sentence if possible, meaning you should choose parameter names that flow with the method name. (e.g. convertPoint:fromRect:or replaceCharactersInRange:withString:). See Apple’s Guide to Naming Methods for more details.Accessor methods should be named the same as the variable they’re “getting”, but they should not be prefixed with the word “get”. For example:- (id)getDelegate; // AVOID- (id)delegate; // GOODThis is for Objective-C methods only. C++ method names and functions continue to follow the rules set in the C++ style guide. Variable NamesVariables names start with a lowercase and use mixed case to delimit words. Instance variables have leading underscores. For example: myLocalVariable, _myInstanceVariable. Common Variable NamesDo not use Hungarian notation for syntactic attributes, such as the static type of a variable (int or pointer). Give as descriptive a name as possible, within reason. Don’t worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. For example: int w; int nerr; int nCompConns; tix = [[NSMutableArray alloc] init]; obj = [someObject object]; p = [network port]; int numErrors; int numCompletedConnections; tickets = [[NSMutableArray alloc] init]; userInfo = [someObject object]; port = [network port]; Instance VariablesInstance variables are mixed case and should be prefixed with an underscore e.g. _usernameTextField. Note that historically the convention was to put the underscore at the end of the name, and projects may opt to continue using trailing underscores in new code in order to maintain consistency within their codebase (see the Historical Notes section). It is recommended you leave old code as-is, unless doing so would create inconsistency within a class. ConstantsConstant names (#defines, enums, const local variables, etc.) should start with a lowercase k and then use mixed case to delimit words. For example: const int kNumberOfFiles = 12; NSString *const kUserKey = @”kUserKey”; enum DisplayTinge { kDisplayTingeGreen = 1, kDisplayTingeBlue = 2 };Because Objective-C does not provide namespacing, constants with global scope should have an appropriate prefix to minimize the chance of name collision, typically like kClassNameFoo. CommentsThough a pain to write, they are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names and then trying to explain them through comments.When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous—the next one may be you!Remember that all of the rules and conventions listed in the C++ Style Guide are in effect here, with a few additional points, below. File CommentsA file may optionally start with a description of its contents.Every file should contain the following items, in order: license boilerplate if neccessary. Choose the appropriate boilerplate for the license used by the project (e.g. Apache 2.0, BSD, LGPL, GPL). a basic description of the contents of the file if necessary. If you make significant changes to a file with an author line, consider deleting the author line since revision history already provides a more detailed and accurate record of authorship. Declaration CommentsEvery interface, category, and protocol declaration should have an accompanying comment describing its purpose and how it fits into the larger picture. // A delegate for NSApplication to handle notifications about app // launch and shutdown. Owned by the main app controller. @interface MyAppDelegate : NSObject { … } @endIf you have already described an interface in detail in the comments at the top of your file feel free to simply state “See comment at top of file for a complete description”, but be sure to have some sort of comment.Additionally, each method in the public interface should have a comment explaining its function, arguments, return value, and any side effects.Document the synchronization assumptions the class makes, if any. If an instance of the class can be accessed by multiple threads, take extra care to document the rules and invariants surrounding multithreaded use. Implementation CommentsUse vertical bars to quote variable names and symbols in comments rather than quotes or naming the symbol inline.This helps eliminate ambiguity, especially when the symbol is a common word that might make the sentence read like it was poorly constructed. E.g. for a symbol “count”:// Sometimes we need |count| to be less than zero.or when quoting something which already contains quotes// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)| Object OwnershipMake the pointer ownership model as explicit as possible when it falls outside the most common Objective-C usage idioms. Manual Reference CountingInstance variables which are pointers to objects derived from NSObject are presumed to be retained, and should be either commented as weak or declared with the __weak lifetime qualifier when applicable. Similarly, declared properties must specify an assign property attribute if they are not retained by the class. An exception is instance variables labeled as IBOutlets in desktop Mac software, which are presumed to not be retained.Where instance variables are pointers to Core Foundation, C++, and other non-Objective-C objects, they should always be declared with strong and weak comments to indicate which pointers are and are not retained. Core Foundation and other non-Objective-C object pointers require explicit memory management, even when building for automatic reference counting or garbage collection.Examples of strong and weak declarations: @interface MyDelegate : NSObject { @private IBOutlet NSButton *_okButton; // Normal NSControl; implicitly weak on Mac only AnObjcObject* _doohickey; // My doohickey __weak MyObjcParent *_parent; // So we can send msgs back (owns me) // non-NSObject pointers... CWackyCPPClass *_wacky; // Strong, some cross-platform object CFDictionaryRef *_dict; // Strong } @property(strong, nonatomic) NSString *doohickey; @property(weak, nonatomic) NSString *parent; @end Automatic Reference CountingObject ownership and lifetime are explicit when using ARC, so no additional comments are required. Cocoa and Objective-C FeaturesInstance Variables In Headers Should Be @privateInstance variables should typically be declared in implementation files or auto-synthesized by properties. When ivars are declared in a header file, they should be marked @private. @interface MyClass : NSObject { @private id _myInstanceVariable; } @end Identify Designated InitializerComment and clearly identify your designated initializer.It is important for those who might be subclassing your class that the designated initializer be clearly identified. That way, they only need to subclass a single initializer (of potentially several) to guarantee their subclass’ initializer is called. It also helps those debugging your class in the future understand the flow of initialization code if they need to step through it. Override Designated InitializerWhen writing a subclass that requires an init... method, make sure you override the superclass’ designated initializer.If you fail to override the superclass’ designated initializer, your initializer may not be called in all cases, leading to subtle and very difficult to find bugs. Overridden NSObject Method PlacementIt is strongly recommended and typical practice to place overridden methods of NSObject at the top of an @implementation.This commonly applies (but is not limited) to the init..., copyWithZone:, and deallocmethods. init... methods should be grouped together, followed by other NSObject methods.Convenience class methods for creating instances may precede the NSObject methods. InitializationDon’t initialize variables to 0 or nil in the init method; it’s redundant.All memory for a newly allocated object is initialized to 0 (except for isa), so don’t clutter up the init method by re-initializing variables to 0 or nil. Avoid +newDo not invoke the NSObject class method new, nor override it in a subclass. Instead, use alloc and init methods to instantiate retained objects.Modern Objective-C code explicitly calls alloc and an init method to create and retain an object. As the newclass method is rarely used, it makes reviewing code for correct memory management more difficult. Keep the Public API SimpleKeep your class simple; avoid “kitchen-sink” APIs. If a method doesn’t need to be public, don’t make it so. Use a private category to prevent cluttering the public header.Unlike C++, Objective-C doesn’t have a way to differentiate between public and private methods—everything is public. As a result, avoid placing methods in the public API unless they are actually expected to be used by a consumer of the class. This helps reduce the likelihood they’ll be called when you’re not expecting it. This includes methods that are being overridden from the parent class. For internal implementation methods, use a category defined in the implementation file as opposed to adding them to the public header. #import &quot;GTMFoo.h&quot; @interface GTMFoo (PrivateDelegateHandling) - (NSString *)doSomethingWithDelegate; // Declare private method @end @implementation GTMFoo (PrivateDelegateHandling) ... - (NSString *)doSomethingWithDelegate { // Implement this method } ... @end If you are using Objective-C 2.0, you should instead declare your private category using a class extension, for example: @interface GMFoo () { … }which will guarantee that the declared methods are implemented in the @implementation section by issuing a compiler warning if they are not.Again, “private” methods are not really private. You could accidentally override a superclass’s “private” method, thus making a very difficult bug to squash. In general, private methods should have a fairly unique name that will prevent subclasses from unintentionally overriding them.Finally, Objective-C categories are a great way to segment a large @implementation section into more understandable chunks and to add new, application-specific functionality to the most appropriate class. For example, instead of adding “middle truncation” code to a random object in your app, make a new category on NSString). #import and #include\#import Objective-C/Objective-C++ headers, and #include C/C++ headers.Choose between #import and #include based on the language of the header that you are including.• When including a header that uses Objective-C or Objective-C++, use #import.• When including a standard C or C++ header, use #include. The header should provide its own #define guard.Some Objective-C headers lack #define guards, and expect to be included only by #import. As Objective-C headers may only be included in Objective-C source files and other Objective-C headers, using #import across the board is appropriate.Standard C and C++ headers without any Objective-C in them can expect to be included by ordinary C and C++ files. Since there is no #import in standard C or C++, such files will be included by #include in those cases. Using #include for them in Objective-C source files as well means that these headers will always be included with the same semantics.This rule helps avoid inadvertent errors in cross-platform projects. A Mac developer introducing a new C or C++ header might forget to add #define guards, which would not cause problems on the Mac if the new header were included with #import, but would break builds on other platforms where #include is used. Being consistent by using #include on all platforms means that compilation is more likely to succeed everywhere or fail everywhere, and avoids the frustration of files working only on some platforms. #import &lt;Cocoa/Cocoa.h&gt; #include &lt;CoreFoundation/CoreFoundation.h&gt; #import &quot;GTMFoo.h&quot; #include &quot;base/basictypes.h&quot; Use Root FrameworksInclude root frameworks over individual files.While it may seem tempting to include individual system headers from a framework such as Cocoa or Foundation, in fact it’s less work on the compiler if you include the top-level root framework. The root framework is generally pre-compiled and can be loaded much more quickly. In addition, remember to use #import rather than #include for Objective-C frameworks. #import &lt;Foundation/Foundation.h&gt; // good #import &lt;Foundation/NSArray.h&gt; // avoid #import &lt;Foundation/NSString.h&gt; ... Prefer To autorelease At Time of CreationWhen creating new temporary objects, autorelease them on the same line as you create them rather than a separate release later in the same method.While ever so slightly slower, this prevents someone from accidentally removing the release or inserting a return before it and introducing a memory leak. E.g.: // AVOID (unless you have a compelling performance reason) MyController* controller = [[MyController alloc] init]; // … code here that might return … [controller release]; // BETTER MyController* controller = [[[MyController alloc] init] autorelease]; Autorelease Then RetainAssignment of objects follows the autorelease then retain pattern.When assigning a new object to a variable, one must first release the old object to avoid a memory leak. There are several “correct” ways to handle this. We’ve chosen the “autorelease then retain” approach because it’s less prone to error. Be aware in tight loops it can fill up the autorelease pool, and may be slightly less efficient, but we feel the tradeoffs are acceptable. - (void)setFoo:(GMFoo *)aFoo { [_foo autorelease]; // Won&apos;t dealloc if |_foo| == |aFoo| _foo = [aFoo retain]; } Avoid Accessors During init and deallocInstance subclasses may be in an inconsistent state during init and dealloc method execution, so code in those methods should avoid invoking accessors.Subclasses have not yet been initialized or have already deallocated when init and dealloc methods execute, making accessor methods potentially unreliable. Whenever practical, directly assign to and release ivars in those methods rather than rely on accessors. - (instancetype)init { self = [super init]; if (self) { _bar = [[NSMutableString alloc] init]; // good } return self; } - (void)dealloc { [_bar release]; // good [super dealloc]; } - (instancetype)init { self = [super init]; if (self) { self.bar = [NSMutableString string]; // avoid } return self; } - (void)dealloc { self.bar = nil; // avoid [super dealloc]; } Dealloc Instance Variables in Declaration Orderdealloc should process instance variables in the same order the @interface declares them, so it is easier for a reviewer to verify.A code reviewer checking a new or revised dealloc implementation needs to make sure that every retained instance variable gets released.To simplify reviewing dealloc, order the code so that the retained instance variables get released in the same order that they are declared in the @interface. If dealloc invokes other methods that release instance variables, add comments describing what instance variables those methods handle. Setters copy NSStringsSetters taking an NSString, should always copy the string it accepts.Never just retain the string. This avoids the caller changing it under you without your knowledge. Don’t assume that because you’re accepting an NSString that it’s not actually anNSMutableString. - (void)setFoo:(NSString *)aFoo { [_foo autorelease]; _foo = [aFoo copy]; } Avoid Throwing ExceptionsDon’t @throw Objective-C exceptions, but you should be prepared to catch them from third-party or OS calls.We do compile with -fobjc-exceptions (mainly so we get @synchronized), but we don’t @throw. Use of @try, @catch, and @finally are allowed when required to properly use 3rd party code or libraries. If you do use them please document exactly which methods you expect to throw. nil ChecksUse nil checks for logic flow only.Use nil pointer checks for logic flow of the application, not for preventing crashes when sending messages. With current compilers ( as of LLVM 3.0/Xcode 4.2), sending a message to nil reliably returns nil as a pointer, zero as an integer or floating-point value, structs initialized to 0, and _Complex values equal to 0, 0.Note that this applies to nil as a message target, not as a parameter value. Individual methods may or may not safely handle nil parameter values.Note too that this is distinct from checking C/C++ pointers and block pointers against NULL, which the runtime does not handle and will cause your application to crash. You still need to make sure you do not dereference a NULL pointer. BOOL PitfallsBe careful when converting general integral values to BOOL. Avoid comparing directly with YES.BOOL is defined as a signed char in Objective-C which means that it can have values other than YES (1) and NO (0). Do not cast or convert general integral values directly to BOOL. Common mistakes include casting or converting an array’s size, a pointer value, or the result of a bitwise logic operation to a BOOL which, depending on the value of the last byte of the integral result, could still result in a NO value. When converting a general integral value to a BOOL use ternary operators to return a YES or NO value.You can safely interchange and convert BOOL, _Bool and bool (see C++ Std 4.7.4, 4.12 and C99 Std 6.3.1.2). You cannot safely interchange BOOL and Boolean so treat Booleans as a general integral value as discussed above. Only use BOOL in Objective C method signatures.Using logical operators (&amp;&amp;, || and !) with BOOL is also valid and will return values that can be safely converted to BOOL without the need for a ternary operator. //avoid - (BOOL)isBold { return [self fontTraits] &amp; NSFontBoldTrait; } - (BOOL)isValid { return [self stringValue]; } //good - (BOOL)isBold { return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO; } - (BOOL)isValid { return [self stringValue] != nil; } - (BOOL)isEnabled { return [self isValid] &amp;&amp; [self isBold]; } Also, don’t directly compare BOOL variables directly with YES. Not only is it harder to read for those well-versed in C, the first point above demonstrates that return values may not always be what you expect. //avoid BOOL great = [foo isGreat]; if (great == YES) // …be great! //good BOOL great = [foo isGreat]; if (great) // ...be great! PropertiesUse of the @property directive is preferred, with the following caveat: properties are an Objective-C 2.0 feature which will limit your code to running on the iPhone and Mac OS X 10.5 (Leopard) and higher. Dot notation is allowed only for access to a declared @property. NamingA property’s associated instance variable’s name must conform to the leading _ requirement. The property’s name should be the same as its associated instance variable without the leading _. The optional space between the @property and the opening parenthesis should be omitted, as seen in the examples. @interface MyClass : NSObject @property(copy, nonatomic) NSString *name; @end @implementation MyClass // No code required for auto-synthesis, else use: // @synthesize name = _name; @end LocationA property’s declaration must come immediately after the instance variable block of a class interface. A property’s definition (if not using automatic synthesis) must come immediately after the @implementation block in a class definition. They are indented at the same level as the @interface or @implementation statements that they are enclosed in. @interface MyClass : NSObject { @private NSString _name; } @property(copy, nonatomic) NSString name; @end @implementation MyClass @synthesize name = _name; - (instancetype)init { ... } @end Use Copy Attribute For StringsNSString properties should always be declared with the copy attribute.This logically follows from the requirement that setters for NSStrings always must use copy instead of retain. AtomicityBe aware of the overhead of properties. By default, all synthesized setters and getters are atomic. This gives each set and get calls a substantial amount of synchronization overhead. Declare your properties nonatomic unless you require atomicity. Dot notationDot notation is idiomatic style for Objective-C 2.0. It may be used when doing simple operations to get and set a @property of an object, but should not be used to invoke other object behavior. NSString *oldName = myObject.name; myObject.name = @”Alice”; //avoid NSArray *array = [[NSArray arrayWithObject:@&quot;hello&quot;] retain]; NSUInteger numberOfItems = array.count; // not a property array.release; // not a property Interfaces Without Instance VariablesOmit the empty set of braces on interfaces that do not declare any instance variables. @interface MyClass : NSObject // Does a lot of stuff - (void)fooBarBam; @end Automatically Synthesized Instance VariablesUse of automatically synthesized instance variables is preferred. Code that must support earlier versions of the compiler toolchain (Xcode 4.3 or earlier or when compiling with GCC) or is using properties inherited from a protocol should prefer the @synthesize directive. // Header file @protocol Thingy @property(nonatomic, copy) NSString *widgetName; @end @interface Foo : NSObject&lt;Thingy&gt; // A guy walks into a bar. @property(nonatomic, copy) NSString *bar; @end // Implementation file @interface Foo () @property(nonatomic, retain) NSArray *baz; @end @implementation Foo @synthesize widgetName = _widgetName; @end Automatically synthesized instance variables take the form of the property’s name prefixed with an underscore and so typically conform to the required variable naming style. If your property name is unusual, or you are otherwise unable to use automatically synthesized instance variables, use of the @synthesize directive is preferred, with the instance variable name specified explicitly (as @synthesize does not add a leading underscore by default). Automatic Reference Counting (ARC)For projects that use Xcode 4.2 or later and will run only on 64-bit Mac OS X 10.7 and iOS 5.0 and later, ARC is preferred. Use manual reference counting when supporting earlier environments where zeroing weak pointers are not available.Classes that require ARC should include a preprocessor directive to prevent compilation using manual reference counting.Ownership qualifiers like __unsafe_unretained and __weak should precede variable names. Specifying __strong for variables is not required since it is the default. Properties, on the other hand, should always specify the strong keyword rather than relying on the compiler default.Files that are compiled using ARC need to have preprocessor directives to prevent compilation without ARC. See the code snippet below for details.Example of an implementation file enforcing ARC style. Note that declaring instance variables in the @implementation is permitted when using ARC. #if !defined(__has_feature) || !__has_feature(objc_arc) #error &quot;This file requires ARC support.&quot; #endif #import &quot;Foo.h&quot; @implementation Foo { Bar* __weak _bar; Baz* __unsafe_unretained _baz; } // ... @end NSNumber LiteralsFor projects that use Xcode 4.4 or later with clang, the use of NSNumber literals is allowed. Note however that this will limit the portability of your code to other toolchains.NSNumber literals are used just like Objective C string literals. Boxing is used when necessary. Code using NSNumber literals can be deployed on any iOS/MacOS system. NSNumber fortyTwo = @42; NSNumber piOverTwo = @(M_PI / 2); enum { kMyEnum = 2; }; NSNumber *myEnum = @(kMyEnum); Cocoa PatternsDelegate PatternDelegate objects should not be retained when doing so would create a retain cycle.A class that implements the delegate pattern should typically: Have an instance variable named _delegate to reference the delegate. Thus, the accessor methods should be named delegate and setDelegate:. The _delegate object should be weak if the class is typically retained by its delegate, such that a strong delegate would create a retain cycle.Model/View/ControllerSeparate the model from the view. Separate the controller from the view and the model. Use @protocols for callback APIs. Separate model from view: don’t build assumptions about the presentation into the model or data source. Keep the interface between the data source and the presentation abstract. Don’t give the model knowledge of its view. (A good rule of thumb is to ask yourself if it’s possible to have multiple presentations, with different states, on a single instance of your data source.) Separate controller from view and model: don’t put all of the “business logic” into view-related classes; this makes the code very unusable. Make controller classes to host this code, but ensure that the controller classes don’t make too many assumptions about the presentation. Define callback APIs with @protocol, using @optional if not all the methods are required.Historical NotesTrailing vs Leading UnderscoresTrailing underscores were once preferred for instance variable names.Our style guide used to have a rule saying that instance variables should be named with a trailing underscore, similar to the naming of member variables in C++. This was changed to leading underscores to be consistent with the broader Objective-C community, to better follow Apple’s official guidelines, and to allow for use of new compiler features like automatic instance variable synthesis. New projects are strongly encouraged to use leading underscores. Existing projects may continue to use trailing underscores in new code to maintain consistency with the rest of their codebase.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[swift style guide]]></title>
      <url>%2F2017%2F04%2F08%2F2017-04-08-swift-style-guide%2F</url>
      <content type="text"><![CDATA[This is LinkedIn’s Official Swift Style GuideMake sure to read Apple’s API Design Guidelines.Specifics from these guidelines + additional remarks are mentioned below.This guide was last updated for Swift 3.0 on January 14th, 2017. Code Formatting Use 4 spaces for tabs. Avoid uncomfortably long lines with a hard maximum of 160 characters per line (Xcode->Preferences->Text Editing->Page guide at column: 160 is helpful for this) Ensure that there is a newline at the end of every file. Ensure that there is no trailing whitespace anywhere (Xcode->Preferences->Text Editing->Automatically trim trailing whitespace + Including whitespace-only lines). Do not place opening braces on new lines - we use the 1TBS style. 12345678910111213class SomeClass &#123; func someMethod() &#123; if x == y &#123; /* ... */ &#125; else if x == z &#123; /* ... */ &#125; else &#123; /* ... */ &#125; &#125; /* ... */&#125; When writing a type for a property, constant, variable, a key for a dictionary, a function argument, a protocol conformance, or a superclass, don’t add a space before the colon. 1234567891011121314151617181920212223242526// specifying typelet pirateViewController: PirateViewController// dictionary syntax (note that we left-align as opposed to aligning colons)let ninjaDictionary: [String: AnyObject] = [ "fightLikeDairyFarmer": false, "disgusting": true]// declaring a functionfunc myFunction&lt;T, U: SomeProtocol&gt;(firstArgument: U, secondArgument: T) where T.RelatedType == U &#123; /* ... */&#125;// calling a functionsomeFunction(someArgument: "Kitten")// superclassesclass PirateViewController: UIViewController &#123; /* ... */&#125;// protocolsextension PirateViewController: UITableViewDataSource &#123; /* ... */&#125; In general, there should be a space following a comma. 1let myArray = [1, 2, 3, 4, 5] There should be a space before and after a binary operator such as +, ==, or -&gt;. There should also not be a space after a ( and before a ). 1234567let myValue = 20 + (30 / 2) * 3if 1 + 1 == 3 &#123; fatalError("The universe is broken.")&#125;func pancake(with syrup: Syrup) -&gt; Pancake &#123; /* ... */&#125; We follow Xcode’s recommended indentation style (i.e. your code should not change if CTRL-I is pressed). When declaring a function that spans multiple lines, prefer using that syntax to which Xcode, as of version 7.3, defaults. 123456789101112131415// Xcode indentation for a function declaration that spans multiple linesfunc myFunctionWithManyParameters(parameterOne: String, parameterTwo: String, parameterThree: String) &#123; // Xcode indents to here for this kind of statement print("\(parameterOne) \(parameterTwo) \(parameterThree)")&#125;// Xcode indentation for a multi-line `if` statementif myFirstValue &gt; (mySecondValue + myThirdValue) &amp;&amp; myFourthValue == .someEnumValue &#123; // Xcode indents to here for this kind of statement print("Hello, World!")&#125; When calling a function that has many parameters, put each argument on a separate line with a single extra indentation. 1234someFunctionWithManyArguments( firstArgument: "Hello, I am a string", secondArgument: resultFromSomeFunction(), thirdArgument: someOtherLocalProperty) When dealing with an implicit array or dictionary large enough to warrant splitting it into multiple lines, treat the [ and ] as if they were braces in a method, if statement, etc. Closures in a method should be treated similarly. 12345678910111213someFunctionWithABunchOfArguments( someStringArgument: "hello I am a string", someArrayArgument: [ "dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa", "string one is crazy - what is it thinking?" ], someDictionaryArgument: [ "dictionary key 1": "some value 1, but also some more text here", "dictionary key 2": "some value 2" ], someClosure: &#123; parameter1 in print(parameter1) &#125;) Prefer using local constants or other mitigation techniques to avoid multi-line predicates where possible. 1234567891011121314// PREFERREDlet firstCondition = x == firstReallyReallyLongPredicateFunction()let secondCondition = y == secondReallyReallyLongPredicateFunction()let thirdCondition = z == thirdReallyReallyLongPredicateFunction()if firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123; // do something&#125;// NOT PREFERREDif x == firstReallyReallyLongPredicateFunction() &amp;&amp; y == secondReallyReallyLongPredicateFunction() &amp;&amp; z == thirdReallyReallyLongPredicateFunction() &#123; // do something&#125; Naming There is no need for Objective-C style prefixing in Swift (e.g. use just GuybrushThreepwood instead of LIGuybrushThreepwood). Use PascalCase for type names (e.g. struct, enum, class, typedef, associatedtype, etc.). Use camelCase (initial lowercase letter) for function, method, property, constant, variable, argument names, enum cases, etc.). When dealing with an acronym or other name that is usually written in all caps, actually use all caps in any names that use this in code. The exception is if this word is at the start of a name that needs to start with lowercase - in this case, use all lowercase for the acronym. 12345678// "HTML" is at the start of a constant name, so we use lowercase "html"let htmlBodyContent: String = "&lt;p&gt;Hello, World!&lt;/p&gt;"// Prefer using ID to Idlet profileID: Int = 1// Prefer URLFinder to UrlFinderclass URLFinder &#123; /* ... */&#125; All constants other than singletons that are instance-independent should be static. All such static constants should be placed in a container enum type as per rule 3.1.16. The naming of this container should be singular (e.g. Constant and not Constants) and it should be named such that it is relatively obvious that it is a constant container. If this is not obvious, you can add a Constant suffix to the name. You should use these containers to group constants that have similar or the same prefixes, suffixes and/or use cases. 12345678910111213141516171819class MyClassName &#123; // PREFERRED enum AccessibilityIdentifier &#123; static let pirateButton = "pirate_button" &#125; enum SillyMathConstant &#123; static let indianaPi = 3 &#125; static let shared = MyClassName() // NOT PREFERRED static let kPirateButtonAccessibilityIdentifier = "pirate_button" enum SillyMath &#123; static let indianaPi = 3 &#125; enum Singleton &#123; static let shared = MyClassName() &#125;&#125; For generics and associated types, use either a single capital letter or a PascalCase word that describes the generic. If this word clashes with a protocol that it conforms to or a superclass that it subclasses, you can append a Type suffix to the associated type or generic name. 12345678class SomeClass&lt;T&gt; &#123; /* ... */ &#125;class SomeClass&lt;Model&gt; &#123; /* ... */ &#125;protocol Modelable &#123; associatedtype Model&#125;protocol Sequence &#123; associatedtype IteratorType: Iterator&#125; Names should be descriptive and unambiguous. 12345// PREFERREDclass RoundAnimatingButton: UIButton &#123; /* ... */ &#125;// NOT PREFERREDclass CustomButton: UIButton &#123; /* ... */ &#125; Do not abbreviate, use shortened names, or single letter names. 123456789101112131415161718// PREFERREDclass RoundAnimatingButton: UIButton &#123; let animationDuration: NSTimeInterval func startAnimating() &#123; let firstSubview = subviews.first &#125;&#125;// NOT PREFERREDclass RoundAnimating: UIButton &#123; let aniDur: NSTimeInterval func srtAnmating() &#123; let v = subviews.first &#125;&#125; Include type information in constant or variable names when it is not obvious otherwise. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// PREFERREDclass ConnectionTableViewCell: UITableViewCell &#123; let personImageView: UIImageView let animationDuration: TimeInterval // it is ok not to include string in the ivar name here because it's obvious // that it's a string from the property name let firstName: String // though not preferred, it is OK to use `Controller` instead of `ViewController` let popupController: UIViewController let popupViewController: UIViewController // when working with a subclass of `UIViewController` such as a table view // controller, collection view controller, split view controller, etc., // fully indicate the type in the name. let popupTableViewController: UITableViewController // when working with outlets, make sure to specify the outlet type in the // property name. @IBOutlet weak var submitButton: UIButton! @IBOutlet weak var emailTextField: UITextField! @IBOutlet weak var nameLabel: UILabel!&#125;// NOT PREFERREDclass ConnectionTableViewCell: UITableViewCell &#123; // this isn't a `UIImage`, so shouldn't be called image // use personImageView instead let personImage: UIImageView // this isn't a `String`, so it should be `textLabel` let text: UILabel // `animation` is not clearly a time interval // use `animationDuration` or `animationTimeInterval` instead let animation: TimeInterval // this is not obviously a `String` // use `transitionText` or `transitionString` instead let transition: String // this is a view controller - not a view let popupView: UIViewController // as mentioned previously, we don't want to use abbreviations, so don't use // `VC` instead of `ViewController` let popupVC: UIViewController // even though this is still technically a `UIViewController`, this property // should indicate that we are working with a *Table* View Controller let popupViewController: UITableViewController // for the sake of consistency, we should put the type name at the end of the // property name and not at the start @IBOutlet weak var btnSubmit: UIButton! @IBOutlet weak var buttonSubmit: UIButton! // we should always have a type in the property name when dealing with outlets // for example, here, we should have `firstNameLabel` instead @IBOutlet weak var firstName: UILabel!&#125; When naming function arguments, make sure that the function can be read easily to understand the purpose of each argument. As per Apple’s API Design Guidelines, a protocol should be named as nouns if they describe what something is doing (e.g. Collection) and using the suffixes able, ible, or ing if it describes a capability (e.g. Equatable, ProgressReporting). If neither of those options makes sense for your use case, you can add a Protocol suffix to the protocol’s name as well. Some example protocols are below.123456789101112131415161718192021// here, the name is a noun that describes what the protocol doesprotocol TableViewSectionProvider &#123; func rowHeight(at row: Int) -&gt; CGFloat var numberOfRows: Int &#123; get &#125; /* ... */&#125;// here, the protocol is a capability, and we name it appropriatelyprotocol Loggable &#123; func logCurrentState() /* ... */&#125;// suppose we have an `InputTextView` class, but we also want a protocol// to generalize some of the functionality - it might be appropriate to// use the `Protocol` suffix hereprotocol InputTextViewProtocol &#123; func sendTrackingEvent() func inputText() -&gt; String /* ... */&#125; Coding StyleGeneral Prefer let to var whenever possible. Prefer the composition of map, filter, reduce, etc. over iterating when transforming from one collection to another. Make sure to avoid using closures that have side effects when using these methods. 123456789101112131415161718192021// PREFERREDlet stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;// ["1", "2", "3"]// NOT PREFERREDvar stringOfInts: [String] = []for integer in [1, 2, 3] &#123; stringOfInts.append(String(integer))&#125;// PREFERREDlet evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;// [4, 8, 16, 42]// NOT PREFERREDvar evenNumbers: [Int] = []for integer in [4, 8, 15, 16, 23, 42] &#123; if integer % 2 == 0 &#123; evenNumbers.append(integer) &#125;&#125; Prefer not declaring types for constants or variables if they can be inferred anyway. If a function returns multiple values, prefer returning a tuple to using inout arguments (it’s best to use labeled tuples for clarity on what you’re returning if it is not otherwise obvious). If you use a certain tuple more than once, consider using a typealias. If you’re returning 3 or more items in a tuple, consider using a struct or class instead. 1234567func pirateName() -&gt; (firstName: String, lastName: String) &#123; return ("Guybrush", "Threepwood")&#125;let name = pirateName()let firstName = name.firstNamelet lastName = name.lastName Be wary of retain cycles when creating delegates/protocols for your classes; typically, these properties should be declared weak. Be careful when calling self directly from an escaping closure as this can cause a retain cycle - use a capture list when this might be the case: 12345678910111213myFunctionWithEscapingClosure() &#123; [weak self] (error) -&gt; Void in // you can do this self?.doSomething() // or you can do this guard let strongSelf = self else &#123; return &#125; strongSelf.doSomething()&#125; Don’t use labeled breaks. Don’t place parentheses around control flow predicates. 123456789// PREFERREDif x == y &#123; /* ... */&#125;// NOT PREFERREDif (x == y) &#123; /* ... */&#125; Avoid writing out an enum type where possible - use shorthand. 12345// PREFERREDimageView.setImageWithURL(url, type: .person)// NOT PREFERREDimageView.setImageWithURL(url, type: AsyncImageView.Type.person) Don’t use shorthand for class methods since it is generally more difficult to infer the context from class methods as opposed to enums. 12345// PREFERREDimageView.backgroundColor = UIColor.white// NOT PREFERREDimageView.backgroundColor = .white Prefer not writing self. unless it is required. When writing methods, keep in mind whether the method is intended to be overridden or not. If not, mark it as final, though keep in mind that this will prevent the method from being overwritten for testing purposes. In general, final methods result in improved compilation times, so it is good to use this when applicable. Be particularly careful, however, when applying the final keyword in a library since it is non-trivial to change something to be non-final in a library as opposed to have changing something to be non-final in your local project. When using a statement such as else, catch, etc. that follows a block, put this keyword on the same line as the block. Again, we are following the 1TBS style here. Example if/else and do/catch code is below. 1234567891011if someBoolean &#123; // do something&#125; else &#123; // do something else&#125;do &#123; let fileContents = try readFile("filename.txt")&#125; catch &#123; print(error)&#125; Prefer static to class when declaring a function or property that is associated with a class as opposed to an instance of that class. Only use class if you specifically need the functionality of overriding that function or property in a subclass, though consider using a protocol to achieve this instead. If you have a function that takes no arguments, has no side effects, and returns some object or value, prefer using a computed property instead. For the purpose of namespacing a set of static functions and/or static properties, prefer using a caseless enum over a class or a struct. This way, you don’t have to add a private init() { } to the container.Access Modifiers Write the access modifier keyword first if it is needed. 12345// PREFERREDprivate static let myPrivateNumber: Int// NOT PREFERREDstatic private let myPrivateNumber: Int The access modifier keyword should not be on a line by itself - keep it inline with what it is describing. 12345678910// PREFERREDopen class Pirate &#123; /* ... */&#125;// NOT PREFERREDopenclass Pirate &#123; /* ... */&#125; In general, do not write the internal access modifier keyword since it is the default. If a property needs to be accessed by unit tests, you will have to make it internal to use @testable import ModuleName. If a property should be private, but you declare it to be internal for the purposes of unit testing, make sure you add an appropriate bit of documentation commenting that explains this. You can make use of the - warning: markup syntax for clarity as shown below. 12345/** This property defines the pirate's name. - warning: Not `private` for `@testable`. */let pirateName = "LeChuck" Prefer private to fileprivate where possible. When choosing between public and open, prefer open if you intend for something to be subclassable outside of a given module and public otherwise. Note that anything internal and above can be subclassed in tests by using @testable import, so this shouldn’t be a reason to use open. In general, lean towards being a bit more liberal with using open when it comes to libraries, but a bit more conservative when it comes to modules in a codebase such as an app where it is easy to change things in multiple modules simultaneously.Custom Operators Prefer creating named functions to custom operators. If you want to introduce a custom operator, make sure that you have a very good reason why you want to introduce a new operator into global scope as opposed to using some other construct. You can override existing operators to support new types (especially ==). However, your new definitions must preserve the semantics of the operator. For example, == must always test equality and return a boolean.Switch Statements and enums When using a switch statement that has a finite set of possibilities (enum), do NOT include a default case. Instead, place unused cases at the bottom and use the break keyword to prevent execution. Since switch cases in Swift break by default, do not include the break keyword if it is not needed. The case statements should line up with the switch statement itself as per default Swift standards. When defining a case that has an associated value, make sure that this value is appropriately labeled as opposed to just types (e.g. case Hunger(hungerLevel: Int) instead of case Hunger(Int)). 12345678910111213141516enum Problem &#123; case attitude case hair case hunger(hungerLevel: Int)&#125;func handleProblem(problem: Problem) &#123; switch problem &#123; case .attitude: print("At least I don't have a hair problem.") case .hair: print("Your barber didn't know when to stop.") case .hunger(let hungerLevel): print("The hunger level is \(hungerLevel).") &#125;&#125; Prefer lists of possibilities (e.g. case 1, 2, 3:) to using the fallthrough keyword where possible). If you have a default case that shouldn’t be reached, preferably throw an error (or handle it some other similar way such as asserting).12345678func handleDigit(_ digit: Int) throws &#123; switch digit &#123; case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9: print("Yes, \(digit) is a digit!") default: throw Error(message: "The given number was not a digit.") &#125;&#125; Optionals The only time you should be using implicitly unwrapped optionals is with @IBOutlets. In every other case, it is better to use a non-optional or regular optional property. Yes, there are cases in which you can probably “guarantee” that the property will never be nil when used, but it is better to be safe and consistent. Similarly, don’t use force unwraps. Don’t use as! or try!. If you don’t plan on actually using the value stored in an optional, but need to determine whether or not this value is nil, explicitly check this value against nil as opposed to using if let syntax. 123456789// PREFEREREDif someOptional != nil &#123; // do something&#125;// NOT PREFERREDif let _ = someOptional &#123; // do something&#125; Don’t use unowned. You can think of unowned as somewhat of an equivalent of a weak property that is implicitly unwrapped (though unowned has slight performance improvements on account of completely ignoring reference counting). Since we don’t ever want to have implicit unwraps, we similarly don’t want unowned properties. 123456// PREFERREDweak var parentViewController: UIViewController?// NOT PREFERREDweak var parentViewController: UIViewController!unowned var parentViewController: UIViewController When unwrapping optionals, use the same name for the unwrapped constant or variable where appropriate. 123guard let myValue = myValue else &#123; return&#125; Protocols When implementing protocols, there are two ways of organizing your code: Using // MARK: comments to separate your protocol implementation from the rest of your code Using an extension outside your class/struct implementation code, but in the same source file Keep in mind that when using an extension, however, the methods in the extension can’t be overridden by a subclass, which can make testing difficult. If this is a common use case, it might be better to stick with method #1 for consistency. Otherwise, method #2 allows for cleaner separation of concerns. Even when using method #2, add // MARK: statements anyway for easier readability in Xcode’s method/property/class/etc. list UI.Properties If making a read-only, computed property, provide the getter without the get {} around it. 123456var computedProperty: String &#123; if someBool &#123; return "I'm a mighty pirate!" &#125; return "I'm selling these fine leather jackets."&#125; When using get {}, set {}, willSet, and didSet, indent these blocks. Though you can create a custom name for the new or old value for willSet/didSet and set, use the standard newValue/oldValue identifiers that are provided by default. 1234567891011121314151617181920var storedProperty: String = "I'm selling these fine leather jackets." &#123; willSet &#123; print("will set to \(newValue)") &#125; didSet &#123; print("did set from \(oldValue) to \(storedProperty)") &#125;&#125;var computedProperty: String &#123; get &#123; if someBool &#123; return "I'm a mighty pirate!" &#125; return storedProperty &#125; set &#123; storedProperty = newValue &#125;&#125; You can declare a singleton property as follows: 12345class PirateManager &#123; static let shared = PirateManager() /* ... */&#125; Closures If the types of the parameters are obvious, it is OK to omit the type name, but being explicit is also OK. Sometimes readability is enhanced by adding clarifying detail and sometimes by taking repetitive parts away - use your best judgment and be consistent. 123456789101112// omitting the typedoSomethingWithClosure() &#123; response in print(response)&#125;// explicit typedoSomethingWithClosure() &#123; response: NSURLResponse in print(response)&#125;// using shorthand in a map statement[1, 2, 3].flatMap &#123; String($0) &#125; If specifying a closure as a type, you don’t need to wrap it in parentheses unless it is required (e.g. if the type is optional or the closure is within another closure). Always wrap the arguments in the closure in a set of parentheses - use () to indicate no arguments and use Void to indicate that nothing is returned. 123456789let completionBlock: (Bool) -&gt; Void = &#123; (success) in print("Success? \(success)")&#125;let completionBlock: () -&gt; Void = &#123; print("Completed!")&#125;let completionBlock: (() -&gt; Void)? = nil Keep parameter names on same line as the opening brace for closures when possible without too much horizontal overflow (i.e. ensure lines are less than 160 characters). Use trailing closure syntax unless the meaning of the closure is not obvious without the parameter name (an example of this could be if a method has parameters for success and failure closures).1234567891011// trailing closuredoSomething(1.0) &#123; (parameter1) in print("Parameter 1 is \(parameter1)")&#125;// no trailing closuredoSomething(1.0, success: &#123; (parameter1) in print("Success with \(parameter1)")&#125;, failure: &#123; (parameter1) in print("Failure with \(parameter1)")&#125;) Arrays In general, avoid accessing an array directly with subscripts. When possible, use accessors such as .first or .last, which are optional and won’t crash. Prefer using a for item in items syntax when possible as opposed to something like for i in 0 ..&lt; items.count. If you need to access an array subscript directly, make sure to do proper bounds checking. You can use for (index, value) in items.enumerated() to get both the index and the value. Never use the += or + operator to append/concatenate to arrays. Instead, use .append() or .append(contentsOf:) as these are far more performant (at least with respect to compilation) in Swift’s current state. If you are declaring an array that is based on other arrays and want to keep it immutable, instead of let myNewArray = arr1 + arr2, use let myNewArray = [arr1, arr2].flatten().Error Handling Suppose a function myFunction is supposed to return a String, however, at some point it can run into an error. A common approach is to have this function return an optional String? where we return nil if something went wrong. Example: 123456789101112131415161718func readFile(named filename: String) -&gt; String? &#123; guard let file = openFile(named: filename) else &#123; return nil &#125; let fileContents = file.read() file.close() return fileContents&#125;func printSomeFile() &#123; let filename = "somefile.txt" guard let fileContents = readFile(named: filename) else &#123; print("Unable to open file \(filename).") return &#125; print(fileContents)&#125; Instead, we should be using Swift’s try/catch behavior when it is appropriate to know the reason for the failure. You can use a struct such as the following: 12345678910111213struct Error: Swift.Error &#123; public let file: StaticString public let function: StaticString public let line: UInt public let message: String public init(message: String, file: StaticString = #file, function: StaticString = #function, line: UInt = #line) &#123; self.file = file self.function = function self.line = line self.message = message &#125;&#125; Example usage: 123456789101112131415161718func readFile(named filename: String) throws -&gt; String &#123; guard let file = openFile(named: filename) else &#123; throw Error(message: "Unable to open file named \(filename).") &#125; let fileContents = file.read() file.close() return fileContents&#125;func printSomeFile() &#123; do &#123; let fileContents = try readFile(named: filename) print(fileContents) &#125; catch &#123; print(error) &#125;&#125; There are some exceptions in which it does make sense to use an optional as opposed to error handling. When the result should semantically potentially be nil as opposed to something going wrong while retrieving the result, it makes sense to return an optional instead of using error handling. In general, if a method can “fail”, and the reason for the failure is not immediately obvious if using an optional return type, it probably makes sense for the method to throw an error.Using guard Statements In general, we prefer to use an “early return” strategy where applicable as opposed to nesting code in if statements. Using guard statements for this use-case is often helpful and can improve the readability of the code. 123456789101112131415161718// PREFERREDfunc eatDoughnut(at index: Int) &#123; guard index &gt;= 0 &amp;&amp; index &lt; doughnuts.count else &#123; // return early because the index is out of bounds return &#125; let doughnut = doughnuts[index] eat(doughnut)&#125;// NOT PREFERREDfunc eatDoughnut(at index: Int) &#123; if index &gt;= 0 &amp;&amp; index &lt; doughnuts.count &#123; let doughnut = doughnuts[index] eat(doughnut) &#125;&#125; When unwrapping optionals, prefer guard statements as opposed to if statements to decrease the amount of nested indentation in your code. 12345678910111213141516171819// PREFERREDguard let monkeyIsland = monkeyIsland else &#123; return&#125;bookVacation(on: monkeyIsland)bragAboutVacation(at: monkeyIsland)// NOT PREFERREDif let monkeyIsland = monkeyIsland &#123; bookVacation(on: monkeyIsland) bragAboutVacation(at: monkeyIsland)&#125;// EVEN LESS PREFERREDif monkeyIsland == nil &#123; return&#125;bookVacation(on: monkeyIsland!)bragAboutVacation(at: monkeyIsland!) When deciding between using an if statement or a guard statement when unwrapping optionals is not involved, the most important thing to keep in mind is the readability of the code. There are many possible cases here, such as depending on two different booleans, a complicated logical statement involving multiple comparisons, etc., so in general, use your best judgement to write code that is readable and consistent. If you are unsure whether guard or if is more readable or they seem equally readable, prefer using guard. 1234567891011121314// an `if` statement is readable hereif operationFailed &#123; return&#125;// a `guard` statement is readable hereguard isSuccessful else &#123; return&#125;// double negative logic like this can get hard to read - i.e. don't do thisguard !operationFailed else &#123; return&#125; If choosing between two different states, it makes more sense to use an if statement as opposed to a guard statement. 1234567891011121314// PREFERREDif isFriendly &#123; print("Hello, nice to meet you!")&#125; else &#123; print("You have the manners of a beggar.")&#125;// NOT PREFERREDguard isFriendly else &#123; print("You have the manners of a beggar.") return&#125;print("Hello, nice to meet you!") You should also use guard only if a failure should result in exiting the current context. Below is an example in which it makes more sense to use two if statements instead of using two guards - we have two unrelated conditions that should not block one another. 1234567if let monkeyIsland = monkeyIsland &#123; bookVacation(onIsland: monkeyIsland)&#125;if let woodchuck = woodchuck, canChuckWood(woodchuck) &#123; woodchuck.chuckWood()&#125; Often, we can run into a situation in which we need to unwrap multiple optionals using guard statements. In general, combine unwraps into a single guard statement if handling the failure of each unwrap is identical (e.g. just a return, break, continue, throw, or some other @noescape). 12345678910111213141516171819// combined because we just returnguard let thingOne = thingOne, let thingTwo = thingTwo, let thingThree = thingThree else &#123; return&#125;// separate statements because we handle a specific error in each caseguard let thingOne = thingOne else &#123; throw Error(message: "Unwrapping thingOne failed.")&#125;guard let thingTwo = thingTwo else &#123; throw Error(message: "Unwrapping thingTwo failed.")&#125;guard let thingThree = thingThree else &#123; throw Error(message: "Unwrapping thingThree failed.")&#125; Don’t use one-liners for guard statements. 1234567// PREFERREDguard let thingOne = thingOne else &#123; return&#125;// NOT PREFERREDguard let thingOne = thingOne else &#123; return &#125; Documentation/CommentsDocumentationIf a function is more complicated than a simple O(1) operation, you should generally consider adding a doc comment for the function since there could be some information that the method signature does not make immediately obvious. If there are any quirks to the way that something was implemented, whether technically interesting, tricky, not obvious, etc., this should be documented. Documentation should be added for complex classes/structs/enums/protocols and properties. All public functions/classes/properties/constants/structs/enums/protocols/etc. should be documented as well (provided, again, that their signature/name does not make their meaning/functionality immediately obvious).After writing a doc comment, you should option click the function/property/class/etc. to make sure that everything is formatted correctly.Be sure to check out the full set of features available in Swift’s comment markup described in Apple’s Documentation.Guidelines: 160 character column limit (like the rest of the code). Even if the doc comment takes up one line, use block (/** */). Do not prefix each additional line with a *. Use the new - parameter syntax as opposed to the old :param: syntax (make sure to use lower case parameter and not Parameter). See the documentation on Swift Markup for more details on how this is formatted. If you’re going to be documenting the parameters/returns/throws of a method, document all of them, even if some of the documentation ends up being somewhat repetitive (this is preferable to having the documentation look incomplete). Sometimes, if only a single parameter warrants documentation, it might be better to just mention it in the description instead. For complicated classes, describe the usage of the class with some potential examples as seems appropriate. Remember that markdown syntax is valid in Swift’s comment docs. Newlines, lists, etc. are therefore appropriate. 12345678910111213141516171819202122232425262728/** ## Feature Support This class does some awesome things. It supports: - Feature 1 - Feature 2 - Feature 3 ## Examples Here is an example use case indented by four spaces because that indicates a code block: let myAwesomeThing = MyAwesomeClass() myAwesomeThing.makeMoney() ## Warnings There are some things you should be careful of: 1. Thing one 2. Thing two 3. Thing three */class MyAwesomeClass &#123; /* ... */&#125; When mentioning code, use code ticks - ` 1234567/** This does something with a `UIViewController`, perchance. - warning: Make sure that `someValue` is `true` before running this function. */func myFunction() &#123; /* ... */&#125; When writing doc comments, prefer brevity where possible. Other Commenting Guidelines Always leave a space after //. Always leave comments on their own line. When using // MARK: - whatever, leave a newline after the comment.12345678910111213class Pirate &#123; // MARK: - instance properties private let pirateName: String // MARK: - initialization init() &#123; /* ... */ &#125;&#125;]]></content>
    </entry>

    
  
  
</search>
